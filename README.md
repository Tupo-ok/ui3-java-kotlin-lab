# Lab Java and Kotlin 

# Lab 1
## Задание #1. Знакомство с языком Java

На этой неделе начнем изучение основ синтаксиса языка Java с решения нескольких
простых программных проблем. Вы также научитесь использовать компилятор Java и
виртуальную машину Java для запуска ваших программ. Ниже приведено описание задач,
которые вам необходимо решить:
Простые числа
Простые числа часто встречаются в задачах по программированию и наш курс не
исключение! Для начала вы должны сделать программу, которая находит и печатает все
простые числа меньше 100. Эта задача даст вам возможность попрактиковаться в
написании циклов и функций на языке Java.
Создайте файл Primes.java, и в этом файле создайте класс как этот:
```java
/**
* TODO: Комментарии, описывающие ваш класс
  */
  public class Primes {
    /**
     * TODO: Комментарии, описывающие этот метод
     */
    public static void main(String[] args) {
        // TODO: здесь напишите свой код
    }
}
  ```
  После создания файла вы можете откомпилировать и запустить программу, но конечно
  пока еще рано делать это. Сначала надо добавить нужный код.
  Внутри класса, после метода main(), добавьте функцию isPrime(int n) которая определяет,
  является ли число простым. Можно считать, что входное значение n всегда больше 2.
  Сигнатура этой функции будет такой:
```java
  public static boolean isPrime(int n){
        // TODO: ваша реализация функции
  }
  ```
  Вы можете реализовать этот метод так, как считаете нужным, но довольно просто сделать
  это с помощью цикла for который перебирает все значения, начиная с 2 до (но, не
  включая) n, проверяя, делится ли n нацело на это значение. Это можно проверить с
  помощью оператора деления по модулю %; например, 17 % 7 равно 3, а 16 % 4 равно 0.
  Если какое либо значение нацело делит аргумент n, return false; если такое значение не
  найдено, то аргумент это простое число: return true. (Оператор return в языке Java
  завершает исполнение метода и возвращает значение вызывающей программе.)
  После того как этот метод написан, вы можете добавить в метод main() другой цикл,
  который перебирает числа от 2 до 100, включительно, печатая числа
  которые isPrime() определяет как простые.
  Откомпилируйте программу и проверьте корректность ее работы! В сети Интернет можно
  найти много таблиц простых чисел, так что проверить результат работы программы будет
  несложно.

Так же там где это указано в заготовке программы добавьте комментарии описывающие
назначение класса и каждого из методов класса. Очень важно вставлять такие
комментарии в свои программы.
Палиндромы
Вторая ваша программа должна определять является ли строка палиндромом. Есть
несколько способов решения этой задачи, но мы выберем тот, который позволит вам
познакомится на практике со свойствами языка Java, которые обсуждались на первой
лекции.
Для этой программы, вы должны создать класс с именем Palindrome, в
файле Palindrome.java. На этот раз можете начать с такого исходного текста:
```java
/**
* TODO: Комментарии с описанием класса
  */
  public class Palindrome {
    /**
     * TODO: Комментарии с описанием метода
     */
    public static void main(String[] args) {
        for(int i = 0; i < args.length; i++) {
            String s = args[i];
            // TODO: определить палиндром ли это и вывести на консоль
            // результат. Поместите s в двойные кавычки при выводе
            // на консоль.
        }
    }
}
  ```
  Как и раньше вы можете сразу откомпилировать и запустить эту программу, хотя в таком
  виде она не покажет ничего интересного.
  Ваша первая задача заключается в том, чтобы создать метод, переставляющий в обратном
  порядке символы в строке. Сигнатура у метода должна быть такая:
```java
  public static String reverseString(String s)
  ```
  Вы можете реализовать этот метод, используя локальную переменную, которая в начале
  инициализируется как пустая строка "", и затем к ней добавляются символы входной
  строки в обратном порядке Объект. String имеет метод length() который возвращает длину
  строки, и метод charAt(int index) который возвращает символ в указанной позиции.
  Индекс должен меняться от 0 до size - 1. Например:
```java
  String s = "pizzeria";
  System.out.println(s.length()); // печатает 8
  System.out.println(s.charAt(5)); // печатает r
  ```
  Можете использовать оператор соединения строк +, или составной оператор
  присвоения += если вам так больше нравится.
  Закончив реализацию метода reverseString(), можете создать другой метод public static
  boolean isPalindrome(String s). Эти методы нужны для того чтобы сделать перестановку
  символов строки s, а затем сравнить ее с исходной строкой. Для проверки равенства

строк String s (или любых других объектов Java), можно использовать
метод equals(Object). Например:
```java
String s1 = "hello";
String s2 = "Hello";
String s3 = "hello";
s1.equals(s2); // равно false
s1.equals(s3); // равно true
```
Не используйте оператор == для сравнения строк! Этот оператор выполняет совсем
другое сравнение в языке Java, о чем мы поговорим в следующей лекции.
Когда закончите писать свой код, откомпилируйте и проверьте вашу программу! На этот
раз передайте программе входные параметры через командную строку, вот так:
java Palindrome madam racecar apple kayak song noon
Ваша программа должна вывести в ответ является ли палиндромом каждое из указанных
слов. Как и раньше добавьте комментарии содержащие описание класса и всех методов в
программе.
Все готово!
Выполнив работу, отправьте файлы .java в moodle для проверки! Не надо отсылать
файлы .class.
Дополнительное задание!
Если у вас появилось желание усовершенствовать вашу программу, сделайте
преобразование строк в нижний регистр и фильтрацию знаков препинания перед
сравнением строк. Есть много фраз палиндромов и будет неплохо добавить в вашу
программу возможность их определения. Например: "Was it a rat I saw?" Or, "Able was I,
ere I saw Elba."
Для идентификации символов пунктуации, букв или пробела, Java имеет много полезных
методов в классе java.lang.Character. Можете познакомиться с этими методами
в документации Java API. Эти методы вызываются так: Character.isLetter(someChar)
Если вы добавите к своей программе возможность анализировать фразы, ее придется
запускать немного иначе. Вы должны заключать фразы в командной строке в двойные
кавычки:
java Palindrome "A man, a plan, a canal -- Panama!"
За выполнение дополнительного задания вы получите дополнительные баллы, но только в
случае если программа будет работать корректно. Для вас это хорошая возможность
попрактиковаться в написании программ на языке Java.

# Lab 2

## Задание #2. Формула Герона

Задание #2: Усложняем задачу
Java объектно-ориентированный язык. В каждом исходном файле .java может быть
объявлен один класс. Класс можно назвать шаблоном для создания объектов. Ниже
показан код простого класса, который описывает точку в двумерном пространстве:
```java
/**
* Точка в двумерном пространстве.
  **/
  public class Point2d {
    /** Координата X точки **/
    private double xCoord;
    /** координата Y точки **/
    private double yCoord;

    /** Конструктор инициализирующий начальное значение координат точки (x,
     y). **/
    public Point2d(double x, double y) {
        xCoord = x;
        yCoord = y;
    }

    /** конструктор без аргументов: по умолчанию точка ставится в начало
     координат. **/
    public Point2d() {
        // Вызываем конструктор с двумя аргументами для инициализации позиции.
        this(0, 0);
    }

    /** Возвращает координату X точки. **/
    public double getX() {
        return xCoord;
    }

    /** Возвращает координату Y точки. **/
    public double getY() {
        return yCoord;
    }

    /** Изменяет координату X точки. **/
    public void setX(double val) {
        xCoord = val;
    }

    /** Изменяет координату Y точки. **/
    public void setY(double val) {
        yCoord = val;
    }
}
  ```
  Этот код должен храниться в файле с именем Point2d.java, по правилам именования
  классов и файлов принятым в языке Java. Копия этого файла нужна вам для выполнения
  этой лабораторной работы. Перепишите ее на ваш компьютер.
  Напомним, что экземпляр класса создается с помощью конструктора в любом месте кода:
```java
Point2d myPoint = new Point2d(); // создает точку в (0,0)
Point2d myOtherPoint = new Point2d(5,3); // создает точку в (5,3)
Point2d aThirdPoint = new Point2d();
```
Будьте внимательны: myPoint != aThirdPoint, даже если их значения одинаковы! Это
происходит потому что оператор сравнения == (и обратный ему оператор !=) проверяют
равенство двух ссылок на объекты. Иначе говоря, == возвращает true если две ссылки
указывают на один и тот же объект. В этом примере,
переменные myPoint и aThirdPoint указывают на разные экземпляры класса Point2d,
следовательно, myPoint == aThirdPoint возвращает false, даже если координаты точек
одинаковы!
Для проверки равенства значений а не ссылок, в классе Point2d нужен метод equals,
который получает через аргумент другой объект (Object), и выполняет нужную проверку
на равенство. Напомним, что типы сравниваемых объектов должны совпадать.
Перед тем отдавать свой код...
Стиль программирования очень важен в любом программном проекте, над которым вы
работаете. Можете верить этому или нет, но большая часть, рабочего времени в
программировании тратится на отладку и сопровождение. На этих этапах жизненного
цикла программ хорошо документированный и читаемый код становится очень важным
фактором экономии времени.
К сожалению, осознание важности хорошего стиля программирования часто приходит
только через болезненный опыт... Но курс, CS11 дает возможность изучить хороший
стиль программирования и попрактиковаться в нем. Перед тем как приступить к работе,
просмотрите руководство по стилю написания программ на языке Java. Имеется также
программа проверки стиля, которая печатает замечания по стилю программирования
вашего кода.
Ваша задача:
Создать новый класс Point3d который описывает, как вы вероятно уже догадались, точку в
трехмерном евклидовом пространстве. Этот класс должен обеспечивать следующий
функционал:
<ul>
<li>Создание новой точки Point3d с тремя указанными значениями координат
(типа double)</li>
<li>Создание новой точки Point3d в позиции (0.0, 0.0, 0.0) по умолчанию,</li>
<li>Чтение и изменение этих трех значений по отдельности, и </li>
<li> Сравнение двух точек Point3ds на равенство значений координат с помощью
метода equals. </li>
</ul>
Внутренние поля объекта Point3d должны быть недоступны напрямую.
Далее, добавьте новый метод distanceTo, который получает другой объект типа Point3d как
аргумент, вычисляет расстояние по прямой до этого объекта, и возвращает это расстояние,
используя тип double.
Создайте второй класс с именем Lab1, который нужен главным образом для объявления
статического метода main. Вспомните, что метод main должен иметь модификатор

доступа public, иметь тип возвращаемого значения void , и иметь один аргумент – массив
элементов типа Strings. Добавьте в класс следующий функционал:
Пользовательский ввод трех троек значений, каждое из которых задает координаты одной
точки в трехмерном пространстве. Создайте из этих входных данных объекты Point3d.
(Пока что, будем считать, что пользователь всегда вводит корректные данные.)
Если вы не знаете, как получить данные от пользователя, найдите нужную функцию
в этом файле.
Сделайте из этой функции метод класса Lab1. Заметим, что этот метод использует классы
из пакета java.io, который не виден вашему коду по умолчанию. Добавьте в начало вашего
файла:
import java.io.*;
Эта строчка добавит классы из пакета java.io к коду класс Lab1. (Это не требуется делать
для классов из пакета java.lang потому что он добавляется к вашему коду автоматически)
Напишите второй статический метод computeArea который получает три точки Point3d's и
вычисляет площадь треугольника ограниченного этими точками. (Возможно, вам
потребуется для этого Формула Герона.) Верните эту площадь в значении типа double.
<li> Используйте данные и код, который вы собрали и написали сами для вычисления и
печати на экране площади треугольника. </li>

Перед вызовом computeArea, однако, проверьте на равенство значений все три
точки Point3d's. Если в какой либо паре точки “одинаковы”, сообщите об этом
пользователю и не вычисляйте площадь.
Откомпилируйте вместе оба ваши файла:
javac Point3d.java Lab1.java
и запустите вашу программу Lab1. Протестируйте ее несколькими простыми
треугольниками.
Когда закончите работу отправьте ее на проверку.

# Lab 3

## Задание #3. Алгоритм A*
Лабораторная работа #3: A*
Если вы когда-либо играли в компьютерную игру с картой, вероятно, вы видели
управляемые компьютером объекты, способные самостоятельно добраться из пункта A в
пункт B. Эта задача, довольно часто встречающаяся как в играх, так и в программах,
написанных для других целей, заключается в поиске маршрута из начальной точки в
пункт назначения, обходящего имеющиеся на карте препятствия.
Один из наиболее известных алгоритмов решения этой задачи называется A*
(произносится "A-звезда"). Это очень эффективный алгоритм, применяемый для поиска
маршрутов в компьютерных программах. Концептуально это очень простой алгоритм. От
начала маршрута, алгоритм постепенно строит путь к конечной точке, на каждом шаге
выбирая лучший маршрут "на данный момент". Таким образом, окончательный маршрут
также будет наилучшим. (Если вы желаете подробнее изучить алгоритм поиска маршрута
A*, можете начать со статьи в Википедии
(http://ru.wikipedia.org/wiki/Алгоритм_поиска_A*), и продолжить изучение, по ссылкам,
которые там приведены.)
Здесь к счастью вам не надо самим реализовывать алгоритм A*; это для вас уже сделано.
Фактически у вас даже есть небольшой и красивый пользовательский интерфейс для
экспериментов с алгоритмом A*:

По клеткам можно кликать мышью, превращая их в барьеры (красные) или разрешенные
для прохода клетки (былые). Голубым цветом обозначаются клетки начала и конца

маршрута. Кнопка "Find Path" запускает вычисление маршрута с помощью алгоритма A*,
и затем отображает его зеленым цветом. Или, если прохода нет, программа не отображает
ничего.
Для реализации алгоритма A* необходимо отслеживать много различной информации, и
классы коллекций Java прекрасно подходят для этой цели. Есть два типа информации,
которую необходимо контролировать в процессе вычисления алгоритма A*:
 Позиции наборы координат клеток с определенными свойствами на двумерной
карте. Алгоритм A* должен использовать информацию об определенных клетках
на карте.
 Точки маршрута отдельные шаги на маршруте, который вычисляет алгоритм A*.
Например, маршрут нарисованный зеленым цветом на рисунке это не что иное, как
последовательность точек маршрута на карте. Каждая точка маршрута хранит
связанную с ней информацию:
o Позицию клетки, в которой находится точка маршрута.
o Ссылку на предыдущую точку маршрута. Построенный маршрут это
последовательность точек маршрута от его начала до конца.
o Стоимость перемещения из начала маршрута в позицию этой точки по
маршруту, заканчивающемуся в этой точке.
o Эвристическая оценка (предположение, другими словами) стоимости
перемещения из этой точки в конечную точку маршрута.

В процессе вычисления маршрута, алгоритм A* должен использовать две основные
коллекции точек маршрута:
 В первой коллекции хранятся "открытые точки маршрута," или точки, которые
еще предстоит проверить алгоритму A*.
 Во второй коллекции хранятся "закрытые точки маршрута," или точки, которые
уже проверены алгоритмом A* и не нуждающиеся в повторной проверке.
Каждая итерация алгоритма A* выглядит очень просто: в списке открытых точек
маршрута находим точку с наименьшей стоимостью маршрута, делаем шаги во всех
направлениях из этой точки для того чтобы создать новые открытые точки маршрута, и
затем перемещаем эту точку маршрута из списка открытых в список закрытых точек. Эта
операция повторяется до тех пор пока текущая точка маршрута не окажется точкой конца
маршрута! Если, в процессе работы алгоритма, открытые точки заканчиваются, маршрута
между начальной и конечной точками не существует.
Эти вычисления зависят главным образом от позиций точек маршрута, следовательно,
полезно хранить точки маршрута в ассоциативном списке, связывающем позиции точек с
соответствующими точками маршрута. Используем контейнер java.util.HashMap для
каждой из этих коллекций. Ключами в нем будут объекты Location(позиция), а
значениями объекты Waypoint (точки маршрута).
Перед началом работы
Перед тем как приступить к работе, загрузите файлы исходных кодов этой лабораторной
работы:
 Map2D.java – карта для алгоритма A*, содержащая информацию о барьерах и
“проходных” клетках

 Location.java – класс содержащий координаты клетки на карте
 Waypoint.java – точка маршрута на карте
 AStarPathfinder.java – класс реализующий алгоритм поиска маршрута A* в
статическом методе
 AStarState.java – этот класс хранит коллекции открытых и закрытых точек
маршрута, а также имеет базовые функции необходимые для работы алгоритма A*
 AStarApp.java - простое Swing приложение которое реализует редактируемое
изображение двухмерной карты, и инициализирует по запросу процесс поиска
маршрута
 JMapCell.java – это пользовательский Swing компонент, который используется для
отображения состояния клетки на карте
Заметим что приложение запускается само по себе без каких либо действий с вашей
стороны, но функции вычисления маршрута заработают только после того как вы
закончите эту лабораторную работу.
Вам требуется внести изменения в текст двух классов: Location и AStarState. Все
остальное это код оболочки Swing который позволяет вам редактировать карту и
отображает маршрут рассчитанный алгоритмом. (Если вы увлеклись и начали, чтобы
заставить программу работать, редактировать другие исходные файлы, остановитесь и
обратитесь за помощью!)
Позиции (класс Location)
Следует начать с подготовки класса Location для использования внутри классов
коллекций Java. Так как в этой работе используются хэш контейнеры, для этого требуется:
 Добавить реализацию метода equals().
 Добавить реализацию метода hashCode().
Добавьте эти методы к классу Location, следуя шаблону внутри класса. После
компиляции, класс Location можно использовать как тип ключа в хэш контейнерах, таких
как HashSet и HashMap.
Состояние A* (Класс AStarState)
Как только класс Location будет готов для использования в качестве ключа, завершите
реализацию класса AStarState. Этот класс содержит множества открытых и закрытых
точек маршрута, и обеспечивает базовые функционал для реализации алгоритма A*.
Повторим, что состояние A* включает две коллекции точек маршрута, одну для открытых
точек и другую для закрытых точек. Для упрощения алгоритма, точки маршрута будут
храниться в ассоциативном хэш списке , в котором ключами будут позиции а значениями
точки маршрута. Мы приходим к такому типу:
HashMap<Location, Waypoint>
(Очевидно, что каждая позиция может иметь только одну, связанную с ней, точку
маршрута. Это как раз то, что нам нужно.)

Добавьте два (не статических) поля этого типа к классу AStarState. Одно для открытых
точек маршрута, другое для закрытых. Не забудьте проинициализировать оба поля так,
чтобы они указывали на новые пустые коллекции.
После того как поля добавлены и правильно проинициализированы, следует добавить
следующие методы к классу AStarState:
public int numOpenWaypoints()
Этот метод должен просто возвращать число элементов в коллекции открытых точек
маршрута. (Да, это делается в одну строчку...)
public Waypoint getMinOpenWaypoint()
Эта функция должна перебирать все элементы в коллекции открытых точек маршрута и
возвращать ссылку на точку с наименьшим значением стоимости маршрута. Если в
коллекции нет элементов, метод должен возвращать null.
Не удаляйте точку из коллекции, возвращая ее; верните только ссылку на точку с
минимальной стоимостью маршрута.

```java 
public boolean addOpenWaypoint(Waypoint newWP)
```
Это самый сложный метод класса состояния A*, но по правде говоря, его реализация
довольно проста. Сложнее других его делает то, что в нем надо добавить новую точку
маршрута, если существующая точка маршрута в позиции “хуже” чем новая. Вот что
должен делать метод:
 Если в позиции нет открытой точки маршрута, просто добавить новую точку.
 Если в коллекции открытых точек уже есть точка маршрута в такой позиции,
добавить новую точку, если then only add the new waypoint if the "previous cost" for
the new waypoint is less than the "previous cost" for the current waypoint. (Make sure to
use the previous cost and not the total cost.) In other words, if the new waypoint
represents a shorter path to that location than the current waypoint does, replace the
current waypoint with the new one.
Здесь, как видно, требуется найти точку маршрута в коллекции открытых точек и, если
она там присутствует, возможно, заменить ее. К счастью это очень просто делается с
помощью метода HashMap.put(), который заменяет старую ассоциацию ключ-значение на
новую.
Метод должен возвращать true, если в коллекцию попадает новая точка маршрута,
и false если этого не происходит.
public boolean isLocationClosed(Location loc)
Эта функция возвращает true если указанная позиция имеется в коллекции закрытых точек
маршрута, иначе false. Так как зарытые точки хранятся в ассоциативном хэш списке в
котором позиция это ключ , сделать такой метод очень просто.
```java
public void closeWaypoint(Location loc)
```

Эта функция перемещает точку маршрута из коллекции открытых точек в коллекцию
закрытых точек. Так как точку можно найти по ее позиции, методу передается позиция
точки.
Процесс перемещения точки выглядит так:
 Удалить точку в указанной позиции из коллекции открытых точек.
 Добавить удаленную точку в коллекцию закрытых точек. Конечно с ключом будет
позиция точки.
Компиляция и тестирование
Закончив реализацию перечисленных функций, запустите программу поиска маршрута,
чтобы убедиться в том, что она работает. Если вы все сделали правильно, не должно быть
проблем с созданием препятствий на карте и поиском пути вокруг них.
Программу можно откомпилировать и запустить как обычно командами:
```nashorn js
javac *.java
java AStarApp
```
Если вы убедили себя в том, что программа работает корректно, отправьте ее на проверку!